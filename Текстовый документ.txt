Привет, у меня есть код можешь пожалуйста его немного поменять, но чтоб он так же продолжил работать, 
package programs;

import com.battle.heroes.army.Army;
import com.battle.heroes.army.Unit;
import com.battle.heroes.army.programs.GeneratePreset;

import java.util.*;

/**
 * Реализация интерфейса GeneratePreset для создания армии с использованием заданных юнитов и максимального количества очков.
 *
 */
public class GeneratePresetImpl implements GeneratePreset {

    /**
     * Метод для генерации армии с учетом максимального количества очков.
     */
@Override
    public Army generate(List<Unit> unitList, int maxPoints) {
        Army computerArmy = new Army(); // Создание новой армии
        List<Unit> selectedUnits = new ArrayList<>(); // Список выбранных юнитов
        int currentPoints = 0; // Текущие очки армии
        Map<String, Integer> unitCounts = new HashMap<>(); // Счётчик юнитов по типам

        for (Unit unit : unitList) {
            // Оценка эффективности юнита по его атакующим и защитным характеристикам
            double efficiency = (double) unit.getBaseAttack() / unit.getCost() +
                    (double) unit.getHealth() / unit.getCost();

            unitCounts.putIfAbsent(unit.getUnitType(), 0); // Если тип юнита ещё не встречался, инициализируем его
            int maxUnitsForType = Math.min(11, maxPoints / unit.getCost()); // Максимальное количество юнитов этого типа

            // Цикл для добавления юнитов в армию, пока не исчерпаем максимальное количество очков
            while (unitCounts.get(unit.getUnitType()) < maxUnitsForType && currentPoints + unit.getCost() <= maxPoints) {
                selectedUnits.add(new Unit(
                        unit.getName(),
                        unit.getUnitType(),
                        unit.getHealth(),
                        unit.getBaseAttack(),
                        unit.getCost(),
                        unit.getAttackType(),
                        unit.getAttackBonuses(),
                        unit.getDefenceBonuses(),
                        unit.getxCoordinate(),
                        unit.getyCoordinate()
                ));

                unitCounts.put(unit.getUnitType(), unitCounts.get(unit.getUnitType()) + 1); // Увеличиваем счётчик юнитов данного типа
                currentPoints += unit.getCost();
            }
        }

        computerArmy.setUnits(selectedUnits); // Устанавливаем выбранные юниты в армию
        computerArmy.setPoints(currentPoints); // Устанавливаем количество очков армии
        return computerArmy; // Возвращаем сформированную армию
    }
}

package programs;

import com.battle.heroes.army.Army;
import com.battle.heroes.army.Unit;
import com.battle.heroes.army.programs.PrintBattleLog;
import com.battle.heroes.army.programs.SimulateBattle;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * Реализация интерфейса SimulateBattle для симуляции битвы между армией игрока и армией компьютера.
 */
public class SimulateBattleImpl implements SimulateBattle {
    private final PrintBattleLog printBattleLog; // Логгер для печати хода битвы

    /**
     * Конструктор для инициализации объекта SimulateBattleImpl.
     */
    public SimulateBattleImpl(PrintBattleLog printBattleLog) {
        this.printBattleLog = printBattleLog;
    }

    /**
     * Метод для симуляции битвы между армиями игрока и компьютера.
     */
    @Override
    public void simulate(Army playerArmy, Army computerArmy) throws InterruptedException {
        List<Unit> playerUnits = new ArrayList<>(playerArmy.getUnits()); // Список юнитов армии игрока
        List<Unit> computerUnits = new ArrayList<>(computerArmy.getUnits()); // Список юнитов армии компьютера

        // Цикл продолжается, пока в обеих армиях есть живые юниты
        while (hasAliveUnits(playerUnits) && hasAliveUnits(computerUnits)) {
            sortUnitsByAttack(playerUnits); // Сортировка юнитов игрока по атаке
            sortUnitsByAttack(computerUnits); // Сортировка юнитов компьютера по атаке

            simulateRound(playerUnits, computerUnits); // Симуляция одного раунда битвы
        }
    }

    /**
     * Проверка наличия живых юнитов в армии.
     */
    private boolean hasAliveUnits(List<Unit> units) {
        return units.stream().anyMatch(Unit::isAlive); // Проверка через поток
    }

    /**
     * Сортировка юнитов по их атакующим характеристикам.
     * @param units список юнитов.
     */
    private void sortUnitsByAttack(List<Unit> units) {
        units.sort((unit1, unit2) -> Integer.compare(unit2.getBaseAttack(), unit1.getBaseAttack()));
    }

    /**
     * Симуляция одного раунда битвы, в котором юниты атакуют друг друга.
     * @param playerUnits список юнитов игрока.
     * @param computerUnits список юнитов компьютера.
     * @throws InterruptedException может быть выброшено при использовании Thread.sleep().
     */
    private void simulateRound(List<Unit> playerUnits, List<Unit> computerUnits) throws InterruptedException {
        performAttacks(playerUnits, computerUnits); // Игрок атакует компьютер
        performAttacks(computerUnits, playerUnits); // Компьютер атакует игрока
    }

    /**
     * Метод для выполнения атак юнитами из атакующей армии.
     */
    private void performAttacks(List<Unit> attackingUnits, List<Unit> defendingUnits) throws InterruptedException {
        Iterator<Unit> iterator = attackingUnits.iterator(); // Итератор для атакующих юнитов

        // Цикл по атакующим юнитам
        while (iterator.hasNext()) {
            Unit attackingUnit = iterator.next();

            if (!attackingUnit.isAlive()) { // Если юнит мёртв, удаляем его
                iterator.remove();
                continue;
            }

            Unit target = attackingUnit.getProgram().attack(); // Получаем цель для атаки

            if (target != null) {
                printBattleLog.printBattleLog(attackingUnit, target); // Логируем атаку
            }

            if (!attackingUnit.isAlive()) { // Если атакующий юнит погиб, удаляем его
                iterator.remove();
            }
        }
    }
}

package programs;

import com.battle.heroes.army.Unit;
import com.battle.heroes.army.programs.SuitableForAttackUnitsFinder;

import java.util.ArrayList;
import java.util.List;

/**
 * Реализация интерфейса SuitableForAttackUnitsFinder для нахождения юнитов, которые могут атаковать.
 */
public class SuitableForAttackUnitsFinderImpl implements SuitableForAttackUnitsFinder {

    /**
     * Метод для получения юнитов, которые могут атаковать в заданной армии.
     */
    @Override
    public List<Unit> getSuitableUnits(List<List<Unit>> unitsByRow, boolean isLeftArmyTarget) {
        List<Unit> suitableUnits = new ArrayList<>();

        for (List<Unit> row : unitsByRow) {
            for (int i = 0; i < row.size(); i++) {
                Unit unit = row.get(i);

                if (unit != null && unit.isAlive()) { // Если юнит живой
                    if (isLeftArmyTarget && isRightmostUnit(unit, row, i)) { // Для левой армии - правый крайний юнит
                        suitableUnits.add(unit);
                    } else if (!isLeftArmyTarget && isLeftmostUnit(unit, row, i)) { // Для правой армии - левый крайний юнит
                        suitableUnits.add(unit);
                    }
                }
            }
        }

        return suitableUnits;
    }

    /**
     * Проверка, является ли юнит самым правым в ряду.
     */
    private boolean isRightmostUnit(Unit unit, List<Unit> row, int unitIndex) {
        for (int i = unitIndex + 1; i < row.size(); i++) {
            if (row.get(i) != null) {
                return false; // Если есть другой юнит справа, то этот не правый
            }
        }
        return true; // Если справа других юнитов нет, это правый
    }

    /**
     * Проверка, является ли юнит самым левым в ряду.
     */
    private boolean isLeftmostUnit(Unit unit, List<Unit> row, int unitIndex) {
        for (int i = unitIndex - 1; i >= 0; i--) {
            if (row.get(i) != null) {
                return false; // Если есть другой юнит слева, то этот не левый
            }
        }
        return true; // Если слева других юнитов нет, это левый
    }
}

package programs;

import com.battle.heroes.army.Unit;
import com.battle.heroes.army.programs.Edge;
import com.battle.heroes.army.programs.UnitTargetPathFinder;

import java.util.*;

/**
 * Реализация интерфейса UnitTargetPathFinder для нахождения пути к цели для юнита.
 */
public class UnitTargetPathFinderImpl implements UnitTargetPathFinder {

    /**
     * Метод для нахождения пути от атакующего юнита к цели с использованием алгоритма поиска в ширину.
     */
    @Override
    public List<Edge> getTargetPath(Unit attackUnit, Unit targetUnit, List<Unit> existingUnitList) {
        final int WIDTH = 27; // Ширина поля
        final int HEIGHT = 21; // Высота поля

        Edge start = new Edge(attackUnit.getxCoordinate(), attackUnit.getyCoordinate()); // Стартовая клетка
        Edge goal = new Edge(targetUnit.getxCoordinate(), targetUnit.getyCoordinate()); // Конечная клетка

        // Если стартовая и конечная клетка совпадают, путь уже найден
        if (start.equals(goal)) {
            return List.of(start);
        }

        // Список занятых клеток (где находятся другие живые юниты)
        Set<Edge> occupiedCells = new HashSet<>();
        for (Unit unit : existingUnitList) {
            if (unit.isAlive()) {
                occupiedCells.add(new Edge(unit.getxCoordinate(), unit.getyCoordinate()));
            }
        }

        // Словарь для хранения расстояний до клеток
        Map<Edge, Integer> distances = new HashMap<>();
        distances.put(start, 0);

        // Словарь для восстановления пути
        Map<Edge, Edge> cameFrom = new HashMap<>();

        // Очередь с приоритетом для алгоритма A*
        PriorityQueue<Edge> queue = new PriorityQueue<>(Comparator.comparingInt(distances::get));
        queue.add(start);

        while (!queue.isEmpty()) {
            Edge current = queue.poll();

            // Если мы достигли цели, восстанавливаем путь
            if (current.equals(goal)) {
                return reconstructPath(cameFrom, current);
            }

            // Обрабатываем соседей текущей клетки
            for (Edge neighbor : getNeighbors(current, WIDTH, HEIGHT)) {
                if (occupiedCells.contains(neighbor)) continue; // Если клетка занята, пропускаем её

                int newDistance = distances.getOrDefault(current, Integer.MAX_VALUE) + 1;

                // Если найден более короткий путь, обновляем расстояние и путь
                if (newDistance < distances.getOrDefault(neighbor, Integer.MAX_VALUE)) {
                    distances.put(neighbor, newDistance);
                    cameFrom.put(neighbor, current);

                    if (!queue.contains(neighbor)) {
                        queue.add(neighbor);
                    }
                }
            }
        }

        return Collections.emptyList(); // Если путь не найден, возвращаем пустой список
    }

    /**
     * Восстановление пути, следуя за родительскими клетками.
     */
    private List<Edge> reconstructPath(Map<Edge, Edge> cameFrom, Edge current) {
        List<Edge> path = new ArrayList<>();
        while (cameFrom.containsKey(current)) {
            path.add(0, current);
            current = cameFrom.get(current);
        }
        path.add(0, current); // Добавляем стартовую клетку в путь
        return path;
    }

    /**
     * Получение соседей для текущей клетки (с учётом размеров поля).
     */
    private List<Edge> getNeighbors(Edge edge, int width, int height) {
        List<Edge> neighbors = new ArrayList<>();
        int x = edge.getX();
        int y = edge.getY();

        if (x > 0) neighbors.add(new Edge(x - 1, y)); //  слева
        if (x < width - 1) neighbors.add(new Edge(x + 1, y)); // справа
        if (y > 0) neighbors.add(new Edge(x, y - 1)); // сверху
        if (y < height - 1) neighbors.add(new Edge(x, y + 1)); // снизу

        return neighbors;
    }
}